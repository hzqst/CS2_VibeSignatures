#!/usr/bin/env python3
"""
Gamedata Update Script for CS2_VibeSignatures

Updates gamedata files for CounterStrikeSharp, CS2Fixes, CS2KZ, Swiftly, SwiftlyS2, and Plugify
from YAML signature files generated by IDA analysis.

Usage:
    python update_gamedata.py -gamever=<version> [-configyaml=config.yaml] [-bindir=bin] [-platform=windows,linux] [-debug]

    -gamever: Game version for YAML path (required)
    -configyaml: Path to config.yaml file (default: config.yaml)
    -bindir: Directory containing YAML files (default: bin)
    -platform: Comma-separated platforms (default: windows,linux)
    -debug: Print detailed information about missing, updated, and skipped symbols

Requirements:
    pip install pyyaml vdf
"""

import argparse
import json
import os
import re
import sys
from pathlib import Path

try:
    import yaml
except ImportError:
    print("Error: Missing required dependency: yaml")
    print("Please install required packages: pip install pyyaml")
    sys.exit(1)

try:
    import vdf
except ImportError:
    print("Error: Missing required dependency: vdf")
    print("Please install required packages: pip install vdf")
    sys.exit(1)


# Default values
DEFAULT_CONFIG_FILE = "config.yaml"
DEFAULT_BIN_DIR = "bin"
DEFAULT_PLATFORMS = "windows,linux"

# Target gamedata file paths (relative to script directory)
CSS_GAMEDATA_PATH = "dist/CounterStrikeSharp/config/addons/counterstrikesharp/gamedata/gamedata.json"
CS2FIXES_GAMEDATA_PATH = "dist/CS2Fixes/gamedata/cs2fixes.games.txt"
CS2KZ_GAMEDATA_PATH = "dist/cs2kz-metamod/gamedata/cs2kz-core.games.txt"
SWIFTLYS2_SIGNATURES_PATH = "dist/swiftlys2/plugin_files/gamedata/cs2/core/signatures.jsonc"
SWIFTLYS2_OFFSETS_PATH = "dist/swiftlys2/plugin_files/gamedata/cs2/core/offsets.jsonc"
PLUGIFY_GAMEDATA_PATH = "dist/plugify-plugin-s2sdk/assets/gamedata.jsonc"


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Update gamedata files from YAML signatures"
    )
    parser.add_argument(
        "-gamever",
        required=True,
        help="Game version for YAML path (required)"
    )
    parser.add_argument(
        "-configyaml",
        default=DEFAULT_CONFIG_FILE,
        help=f"Path to config.yaml file (default: {DEFAULT_CONFIG_FILE})"
    )
    parser.add_argument(
        "-bindir",
        default=DEFAULT_BIN_DIR,
        help=f"Directory containing YAML files (default: {DEFAULT_BIN_DIR})"
    )
    parser.add_argument(
        "-platform",
        default=DEFAULT_PLATFORMS,
        help=f"Comma-separated platforms (default: {DEFAULT_PLATFORMS})"
    )
    parser.add_argument(
        "-debug",
        action="store_true",
        help="Print detailed information about missing and updated symbols"
    )

    return parser.parse_args()


def load_config(config_path):
    """
    Load and parse config.yaml file.

    Args:
        config_path: Path to the config.yaml file

    Returns:
        Dictionary containing config data
    """
    with open(config_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def strip_jsonc_comments(content):
    """
    Strip comments from JSONC content.

    Removes both single-line (//) and multi-line (/* */) comments,
    while preserving strings that might contain comment-like patterns.

    Args:
        content: JSONC content string

    Returns:
        JSON content string without comments
    """
    result = []
    i = 0
    in_string = False
    escape_next = False

    while i < len(content):
        char = content[i]

        if escape_next:
            result.append(char)
            escape_next = False
            i += 1
            continue

        if char == '\\' and in_string:
            result.append(char)
            escape_next = True
            i += 1
            continue

        if char == '"' and not escape_next:
            in_string = not in_string
            result.append(char)
            i += 1
            continue

        if not in_string:
            # Check for single-line comment
            if char == '/' and i + 1 < len(content) and content[i + 1] == '/':
                # Skip until end of line
                while i < len(content) and content[i] != '\n':
                    i += 1
                continue

            # Check for multi-line comment
            if char == '/' and i + 1 < len(content) and content[i + 1] == '*':
                i += 2
                # Skip until */
                while i + 1 < len(content):
                    if content[i] == '*' and content[i + 1] == '/':
                        i += 2
                        break
                    i += 1
                continue

        result.append(char)
        i += 1

    return ''.join(result)


def load_jsonc(file_path):
    """
    Load and parse a JSONC file (JSON with comments).

    Args:
        file_path: Path to the JSONC file

    Returns:
        Parsed JSON data as dictionary
    """
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()
    content = strip_jsonc_comments(content)
    return json.loads(content)


def save_jsonc(file_path, data, original_content=None):
    """
    Save data to a JSONC file, preserving comments if original content provided.

    Since preserving comments is complex, we just write clean JSON for now.

    Args:
        file_path: Path to the JSONC file
        data: Data to save
        original_content: Original file content (unused for now)
    """
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)
        f.write("\n")


def load_yaml_data(yaml_path):
    """
    Load a single YAML signature file.

    Args:
        yaml_path: Path to the YAML file

    Returns:
        Dictionary containing YAML data, or None if file doesn't exist
    """
    if not os.path.exists(yaml_path):
        return None

    with open(yaml_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def build_function_library_map(config):
    """
    Build a mapping from function names to library names.

    Args:
        config: Parsed config.yaml data

    Returns:
        Dictionary mapping function names (and aliases) to library names
    """
    func_lib_map = {}

    for module in config.get("modules", []):
        module_name = module.get("name")
        if not module_name:
            continue

        for symbol in module.get("symbols", []):
            func_name = symbol.get("name")
            if func_name:
                func_lib_map[func_name] = module_name

                # Also add aliases
                for alias in symbol.get("alias", []):
                    func_lib_map[alias] = module_name

    return func_lib_map


def build_function_category_map(config):
    """
    Build a mapping from function names to categories (func/vfunc).

    Args:
        config: Parsed config.yaml data

    Returns:
        Dictionary mapping function names to categories
    """
    func_cat_map = {}

    for module in config.get("modules", []):
        for symbol in module.get("symbols", []):
            func_name = symbol.get("name")
            category = symbol.get("catagory")  # Note: typo in original config
            if func_name and category:
                func_cat_map[func_name] = category

                # Also add aliases
                for alias in symbol.get("alias", []):
                    func_cat_map[alias] = category

    return func_cat_map


def build_alias_to_name_map(config):
    """
    Build a mapping from aliases to function names.

    Args:
        config: Parsed config.yaml data

    Returns:
        Dictionary mapping aliases to function names
    """
    alias_to_name = {}

    for module in config.get("modules", []):
        for symbol in module.get("symbols", []):
            func_name = symbol.get("name")
            if func_name:
                for alias in symbol.get("alias", []):
                    alias_to_name[alias] = func_name

    return alias_to_name


def normalize_func_name_colons_to_underscore(name, alias_to_name_map=None):
    """
    Convert function name from double-colon format to underscore format.

    First looks up the name in the alias_to_name_map from config.yaml.
    If not found, falls back to simple :: to _ replacement.

    Example: CCSPlayerController::ChangeTeam -> CCSPlayerController_ChangeTeam

    Args:
        name: Function name with double colons
        alias_to_name_map: Optional mapping from aliases to names (from config.yaml)

    Returns:
        Function name with underscores
    """
    # First try to find in config.yaml aliases
    if alias_to_name_map and name in alias_to_name_map:
        return alias_to_name_map[name]

    # Fallback: simple replacement
    return name.replace("::", "_")


# =============================================================================
# Signature Format Converters
# =============================================================================

def convert_sig_to_css(sig):
    """
    Convert YAML signature to CounterStrikeSharp format.

    YAML: "48 89 5C 24 ?? 48 8B D9"
    CSS:  "48 89 5C 24 ? 48 8B D9"

    Args:
        sig: Signature string from YAML

    Returns:
        Converted signature string
    """
    return sig.replace("??", "?")


def convert_sig_to_cs2fixes(sig):
    """
    Convert YAML signature to CS2Fixes VDF format.

    YAML: "48 89 5C 24 ?? 48 8B D9"
    VDF:  "\\x48\\x89\\x5C\\x24\\x2A\\x48\\x8B\\xD9"

    Args:
        sig: Signature string from YAML

    Returns:
        Converted signature string with \\xHH format
    """
    parts = sig.split()
    result = []
    for part in parts:
        if part == "??":
            result.append("\\x2A")
        else:
            result.append(f"\\x{part}")
    return "".join(result)


def convert_sig_to_swiftly(sig):
    """
    Convert YAML signature to Swiftly format.

    YAML: "48 89 5C 24 ?? 48 8B D9"
    Swiftly: "48 89 5C 24 ? 48 8B D9"

    Args:
        sig: Signature string from YAML

    Returns:
        Converted signature string
    """
    return sig.replace("??", "?")


# =============================================================================
# YAML Data Loader
# =============================================================================

def load_all_yaml_data(config, bin_dir, gamever, platforms, debug=False):
    """
    Load all YAML signature data for the specified game version.

    Args:
        config: Parsed config.yaml data
        bin_dir: Base directory for YAML files
        gamever: Game version subdirectory
        platforms: List of platforms to load
        debug: If True, collect missing symbols info

    Returns:
        Tuple: (yaml_data dict, missing_symbols list)
        yaml_data: {func_name: {"library": str, "category": str, platform: yaml_data}}
        missing_symbols: List of {"name": str, "library": str, "platform": str, "path": str}
    """
    yaml_data = {}
    missing_symbols = []

    for module in config.get("modules", []):
        module_name = module.get("name")
        if not module_name:
            continue

        for symbol in module.get("symbols", []):
            func_name = symbol.get("name")
            if not func_name:
                continue

            yaml_data[func_name] = {
                "library": module_name,
                "category": symbol.get("catagory")
            }

            for platform in platforms:
                yaml_path = os.path.join(
                    bin_dir, gamever, module_name, f"{func_name}.{platform}.yaml"
                )
                data = load_yaml_data(yaml_path)
                if data:
                    yaml_data[func_name][platform] = data
                else:
                    if debug:
                        missing_symbols.append({
                            "name": func_name,
                            "library": module_name,
                            "platform": platform,
                            "path": yaml_path
                        })
                    print(f"  Warning: YAML not found: {yaml_path}")

    return yaml_data, missing_symbols


# =============================================================================
# CounterStrikeSharp Updater
# =============================================================================

def update_counterstrikesharp(yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug=False):
    """
    Update CounterStrikeSharp gamedata.json file.

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        script_dir: Script directory for resolving paths
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
        updated_symbols: List of {"name": str, "type": str, "platform": str}
        skipped_symbols: List of {"name": str, "reason": str}
    """
    gamedata_path = os.path.join(script_dir, CSS_GAMEDATA_PATH)

    if not os.path.exists(gamedata_path):
        print(f"  Warning: CounterStrikeSharp gamedata not found: {gamedata_path}")
        return 0, 0, [], []

    # Load existing gamedata
    with open(gamedata_path, "r", encoding="utf-8") as f:
        gamedata = json.load(f)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    for func_name, entry in gamedata.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Determine library for this function
        library = None
        if "signatures" in entry and "library" in entry["signatures"]:
            library = entry["signatures"]["library"]
        elif yaml_func_name in func_lib_map:
            library = func_lib_map[yaml_func_name]

        if not library:
            print(f"  Warning: Unknown library for {func_name}, skipping")
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "unknown library"
                })
            continue

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry or yaml_entry.get("library") != library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update signatures
        if "signatures" in entry:
            for platform in platforms:
                if platform in yaml_entry and "func_sig" in yaml_entry[platform]:
                    sig = convert_sig_to_css(yaml_entry[platform]["func_sig"])
                    entry["signatures"][platform] = sig
                    updated_count += 1
                    if debug:
                        updated_symbols.append({
                            "name": func_name,
                            "type": "signature",
                            "platform": platform
                        })

        # Update offsets (vfunc_index)
        if "offsets" in entry:
            for platform in platforms:
                if platform in yaml_entry and "vfunc_index" in yaml_entry[platform]:
                    entry["offsets"][platform] = yaml_entry[platform]["vfunc_index"]
                    updated_count += 1
                    if debug:
                        updated_symbols.append({
                            "name": func_name,
                            "type": "offset",
                            "platform": platform
                        })

    # Write back
    with open(gamedata_path, "w", encoding="utf-8") as f:
        json.dump(gamedata, f, indent=2)
        f.write("\n")

    return updated_count, skipped_count, updated_symbols, skipped_symbols


# =============================================================================
# CS2Fixes Updater
# =============================================================================

def update_cs2fixes(yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug=False):
    """
    Update CS2Fixes cs2fixes.games.txt file (VDF format).

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        script_dir: Script directory for resolving paths
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
        updated_symbols: List of {"name": str, "type": str, "platform": str}
        skipped_symbols: List of {"name": str, "reason": str}
    """
    gamedata_path = os.path.join(script_dir, CS2FIXES_GAMEDATA_PATH)

    if not os.path.exists(gamedata_path):
        print(f"  Warning: CS2Fixes gamedata not found: {gamedata_path}")
        return 0, 0, [], []

    # Load existing gamedata (handle BOM)
    with open(gamedata_path, "r", encoding="utf-8-sig") as f:
        content = f.read()

    # Parse VDF
    gamedata = vdf.loads(content)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    # Navigate to csgo section
    csgo = gamedata.get("Games", {}).get("csgo", {})

    # Update Signatures
    signatures = csgo.get("Signatures", {})
    for func_name, entry in signatures.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Determine library
        library = entry.get("library")
        if not library and yaml_func_name in func_lib_map:
            library = func_lib_map[yaml_func_name]

        if not library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "unknown library"
                })
            continue

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry or yaml_entry.get("library") != library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update platform signatures
        for platform in platforms:
            if platform in yaml_entry and "func_sig" in yaml_entry[platform]:
                sig = convert_sig_to_cs2fixes(yaml_entry[platform]["func_sig"])
                entry[platform] = sig
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "signature",
                        "platform": platform
                    })

    # Update Offsets
    offsets = csgo.get("Offsets", {})
    for func_name, entry in offsets.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data (offset)"
                })
            continue

        # Update platform offsets
        for platform in platforms:
            if platform in yaml_entry and "vfunc_index" in yaml_entry[platform]:
                # CS2Fixes uses string values for offsets
                entry[platform] = str(yaml_entry[platform]["vfunc_index"])
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "offset",
                        "platform": platform
                    })

    # Write back with BOM
    # Use vdf.dumps() to get string, then manually fix escaped backslashes
    vdf_content = vdf.dumps(gamedata, pretty=True)
    # VDF library escapes backslashes, but CS2Fixes expects single backslash
    # Replace \\x with \x in signature strings
    vdf_content = vdf_content.replace("\\\\x", "\\x")

    with open(gamedata_path, "w", encoding="utf-8-sig") as f:
        f.write(vdf_content)

    return updated_count, skipped_count, updated_symbols, skipped_symbols


# =============================================================================
# CS2KZ Updater
# =============================================================================

def update_cs2kz(yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug=False):
    """
    Update CS2KZ cs2kz-core.games.txt file (VDF format).

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        script_dir: Script directory for resolving paths
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
        updated_symbols: List of {"name": str, "type": str, "platform": str}
        skipped_symbols: List of {"name": str, "reason": str}
    """
    gamedata_path = os.path.join(script_dir, CS2KZ_GAMEDATA_PATH)

    if not os.path.exists(gamedata_path):
        print(f"  Warning: CS2KZ gamedata not found: {gamedata_path}")
        return 0, 0, [], []

    # Load existing gamedata (handle BOM)
    with open(gamedata_path, "r", encoding="utf-8-sig") as f:
        content = f.read()

    # Parse VDF
    gamedata = vdf.loads(content)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    # Navigate to csgo section
    csgo = gamedata.get("Games", {}).get("csgo", {})

    # Update Signatures
    signatures = csgo.get("Signatures", {})
    for func_name, entry in signatures.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Determine library
        library = entry.get("library")
        if not library and yaml_func_name in func_lib_map:
            library = func_lib_map[yaml_func_name]

        if not library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "unknown library"
                })
            continue

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry or yaml_entry.get("library") != library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update platform signatures
        for platform in platforms:
            if platform in yaml_entry and "func_sig" in yaml_entry[platform]:
                sig = convert_sig_to_cs2fixes(yaml_entry[platform]["func_sig"])
                entry[platform] = sig
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "signature",
                        "platform": platform
                    })

    # Update Offsets
    offsets = csgo.get("Offsets", {})
    for func_name, entry in offsets.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data (offset)"
                })
            continue

        # Update platform offsets
        for platform in platforms:
            if platform in yaml_entry and "vfunc_index" in yaml_entry[platform]:
                # CS2KZ uses string values for offsets (same as CS2Fixes)
                entry[platform] = str(yaml_entry[platform]["vfunc_index"])
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "offset",
                        "platform": platform
                    })

    # Write back with BOM
    # Use vdf.dumps() to get string, then manually fix escaped backslashes
    vdf_content = vdf.dumps(gamedata, pretty=True)
    # VDF library escapes backslashes, but CS2KZ expects single backslash
    # Replace \\x with \x in signature strings
    vdf_content = vdf_content.replace("\\\\x", "\\x")

    with open(gamedata_path, "w", encoding="utf-8-sig") as f:
        f.write(vdf_content)

    return updated_count, skipped_count, updated_symbols, skipped_symbols


# =============================================================================
# SwiftlyS2 Updater (JSONC format with :: naming)
# =============================================================================

def update_swiftlys2(yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug=False):
    """
    Update SwiftlyS2 signatures.jsonc and offsets.jsonc files.

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        script_dir: Script directory for resolving paths
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
    """
    total_updated = 0
    total_skipped = 0
    all_updated_symbols = []
    all_skipped_symbols = []

    # Update signatures.jsonc
    sig_path = os.path.join(script_dir, SWIFTLYS2_SIGNATURES_PATH)
    if os.path.exists(sig_path):
        updated, skipped, updated_syms, skipped_syms = update_swiftlys2_signatures(
            yaml_data, func_lib_map, platforms, sig_path, alias_to_name_map, debug
        )
        total_updated += updated
        total_skipped += skipped
        all_updated_symbols.extend(updated_syms)
        all_skipped_symbols.extend(skipped_syms)
    else:
        print(f"  Warning: SwiftlyS2 signatures not found: {sig_path}")

    # Update offsets.jsonc
    off_path = os.path.join(script_dir, SWIFTLYS2_OFFSETS_PATH)
    if os.path.exists(off_path):
        updated, skipped, updated_syms, skipped_syms = update_swiftlys2_offsets(
            yaml_data, func_lib_map, platforms, off_path, alias_to_name_map, debug
        )
        total_updated += updated
        total_skipped += skipped
        all_updated_symbols.extend(updated_syms)
        all_skipped_symbols.extend(skipped_syms)
    else:
        print(f"  Warning: SwiftlyS2 offsets not found: {off_path}")

    return total_updated, total_skipped, all_updated_symbols, all_skipped_symbols


def update_swiftlys2_signatures(yaml_data, func_lib_map, platforms, sig_path, alias_to_name_map, debug=False):
    """
    Update SwiftlyS2 signatures.jsonc file.

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        sig_path: Path to signatures.jsonc
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
    """
    signatures = load_jsonc(sig_path)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    for func_name, entry in signatures.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Determine library
        library = entry.get("lib")
        if not library and yaml_func_name in func_lib_map:
            library = func_lib_map[yaml_func_name]

        if not library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "unknown library"
                })
            continue

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry or yaml_entry.get("library") != library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update platform signatures
        for platform in platforms:
            if platform in yaml_entry and "func_sig" in yaml_entry[platform]:
                sig = convert_sig_to_swiftly(yaml_entry[platform]["func_sig"])
                entry[platform] = sig
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "signature",
                        "platform": platform
                    })

    # Write back
    save_jsonc(sig_path, signatures)

    return updated_count, skipped_count, updated_symbols, skipped_symbols


def update_swiftlys2_offsets(yaml_data, func_lib_map, platforms, off_path, alias_to_name_map, debug=False):
    """
    Update SwiftlyS2 offsets.jsonc file.

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        off_path: Path to offsets.jsonc
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
    """
    offsets = load_jsonc(off_path)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    for func_name, entry in offsets.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update platform offsets
        for platform in platforms:
            if platform in yaml_entry and "vfunc_index" in yaml_entry[platform]:
                entry[platform] = yaml_entry[platform]["vfunc_index"]
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "offset",
                        "platform": platform
                    })

    # Write back
    save_jsonc(off_path, offsets)

    return updated_count, skipped_count, updated_symbols, skipped_symbols


# =============================================================================
# Plugify Updater (JSONC format with :: naming and win64/linuxsteamrt64 keys)
# =============================================================================

def update_plugify(yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug=False):
    """
    Update Plugify gamedata.jsonc file.

    Args:
        yaml_data: Loaded YAML data
        func_lib_map: Function name to library mapping
        platforms: List of platforms to update
        script_dir: Script directory for resolving paths
        alias_to_name_map: Mapping from aliases to function names
        debug: If True, collect updated and skipped symbols info

    Returns:
        Tuple of (updated_count, skipped_count, updated_symbols, skipped_symbols)
    """
    gamedata_path = os.path.join(script_dir, PLUGIFY_GAMEDATA_PATH)

    if not os.path.exists(gamedata_path):
        print(f"  Warning: Plugify gamedata not found: {gamedata_path}")
        return 0, 0, [], []

    gamedata = load_jsonc(gamedata_path)

    updated_count = 0
    skipped_count = 0
    updated_symbols = []
    skipped_symbols = []

    # Platform key mapping: windows -> win64, linux -> linuxsteamrt64
    platform_map = {
        "windows": "win64",
        "linux": "linuxsteamrt64"
    }

    # Process csgo section (main game)
    csgo = gamedata.get("csgo", {})

    # Update Signatures
    signatures = csgo.get("Signatures", {})
    for func_name, entry in signatures.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Determine library
        library = entry.get("library")
        if not library and yaml_func_name in func_lib_map:
            library = func_lib_map[yaml_func_name]

        if not library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "unknown library"
                })
            continue

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry or yaml_entry.get("library") != library:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data"
                })
            continue

        # Update platform signatures
        for platform in platforms:
            plugify_platform = platform_map.get(platform)
            if not plugify_platform:
                continue
            if platform in yaml_entry and "func_sig" in yaml_entry[platform]:
                sig = convert_sig_to_swiftly(yaml_entry[platform]["func_sig"])
                entry[plugify_platform] = sig
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "signature",
                        "platform": platform
                    })

    # Update Offsets
    offsets = csgo.get("Offsets", {})
    for func_name, entry in offsets.items():
        # Convert :: to _ for matching with YAML data
        yaml_func_name = normalize_func_name_colons_to_underscore(func_name, alias_to_name_map)

        # Find matching YAML data
        yaml_entry = yaml_data.get(yaml_func_name)
        if not yaml_entry:
            skipped_count += 1
            if debug:
                skipped_symbols.append({
                    "name": func_name,
                    "reason": "no matching YAML data (offset)"
                })
            continue

        # Update platform offsets
        for platform in platforms:
            plugify_platform = platform_map.get(platform)
            if not plugify_platform:
                continue
            if platform in yaml_entry and "vfunc_index" in yaml_entry[platform]:
                entry[plugify_platform] = yaml_entry[platform]["vfunc_index"]
                updated_count += 1
                if debug:
                    updated_symbols.append({
                        "name": func_name,
                        "type": "offset",
                        "platform": platform
                    })

    # Write back
    save_jsonc(gamedata_path, gamedata)

    return updated_count, skipped_count, updated_symbols, skipped_symbols


# =============================================================================
# Debug Output Helper
# =============================================================================

def print_debug_info(title, missing_symbols, updated_symbols, skipped_symbols):
    """
    Print detailed debug information.

    Args:
        title: Section title
        missing_symbols: List of missing symbols from YAML loading
        updated_symbols: Dict of {target_name: list of updated symbols}
        skipped_symbols: Dict of {target_name: list of skipped symbols}
    """
    print(f"\n{'=' * 60}")
    print(f"DEBUG INFO: {title}")
    print("=" * 60)

    if missing_symbols:
        print(f"\n[Missing YAML Files] ({len(missing_symbols)} items)")
        for item in missing_symbols:
            print(f"  - {item['name']} ({item['library']}/{item['platform']})")

    for target_name, symbols in updated_symbols.items():
        if symbols:
            print(f"\n[{target_name}] Updated Symbols ({len(symbols)} items)")
            for item in symbols:
                print(f"  + {item['name']} ({item['type']}/{item['platform']})")

    for target_name, symbols in skipped_symbols.items():
        if symbols:
            print(f"\n[{target_name}] Skipped Symbols ({len(symbols)} items)")
            for item in symbols:
                print(f"  - {item['name']}: {item['reason']}")


# =============================================================================
# Main
# =============================================================================

def main():
    """Main entry point."""
    args = parse_args()

    config_path = args.configyaml
    bin_dir = args.bindir
    gamever = args.gamever
    platforms = [p.strip() for p in args.platform.split(",")]
    debug = args.debug

    # Get script directory for resolving relative paths
    script_dir = os.path.dirname(os.path.abspath(__file__))

    # Validate config file exists
    if not os.path.exists(config_path):
        print(f"Error: Config file not found: {config_path}")
        sys.exit(1)

    print(f"Config file: {config_path}")
    print(f"Binary directory: {bin_dir}")
    print(f"Game version: {gamever}")
    print(f"Platforms: {', '.join(platforms)}")
    if debug:
        print("Debug mode: enabled")

    # Load config
    print("\nLoading config...")
    config = load_config(config_path)

    # Build function mappings
    func_lib_map = build_function_library_map(config)
    print(f"Found {len(func_lib_map)} function mappings")

    # Build alias to name mapping for :: to _ conversion
    alias_to_name_map = build_alias_to_name_map(config)

    # Load all YAML data
    print("\nLoading YAML data...")
    yaml_data, missing_symbols = load_all_yaml_data(config, bin_dir, gamever, platforms, debug)
    print(f"Loaded data for {len(yaml_data)} functions")

    # Collect debug info
    all_updated_symbols = {}
    all_skipped_symbols = {}

    # Update each gamedata format
    print("\n" + "=" * 50)
    print("Updating CounterStrikeSharp...")
    css_updated, css_skipped, css_updated_syms, css_skipped_syms = update_counterstrikesharp(
        yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug
    )
    print(f"  Updated: {css_updated}, Skipped: {css_skipped}")
    all_updated_symbols["CounterStrikeSharp"] = css_updated_syms
    all_skipped_symbols["CounterStrikeSharp"] = css_skipped_syms

    print("\n" + "=" * 50)
    print("Updating CS2Fixes...")
    cs2f_updated, cs2f_skipped, cs2f_updated_syms, cs2f_skipped_syms = update_cs2fixes(
        yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug
    )
    print(f"  Updated: {cs2f_updated}, Skipped: {cs2f_skipped}")
    all_updated_symbols["CS2Fixes"] = cs2f_updated_syms
    all_skipped_symbols["CS2Fixes"] = cs2f_skipped_syms

    print("\n" + "=" * 50)
    print("Updating CS2KZ...")
    cs2kz_updated, cs2kz_skipped, cs2kz_updated_syms, cs2kz_skipped_syms = update_cs2kz(
        yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug
    )
    print(f"  Updated: {cs2kz_updated}, Skipped: {cs2kz_skipped}")
    all_updated_symbols["CS2KZ"] = cs2kz_updated_syms
    all_skipped_symbols["CS2KZ"] = cs2kz_skipped_syms

    print("\n" + "=" * 50)
    print("Updating SwiftlyS2...")
    swifts2_updated, swifts2_skipped, swifts2_updated_syms, swifts2_skipped_syms = update_swiftlys2(
        yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug
    )
    print(f"  Updated: {swifts2_updated}, Skipped: {swifts2_skipped}")
    all_updated_symbols["SwiftlyS2"] = swifts2_updated_syms
    all_skipped_symbols["SwiftlyS2"] = swifts2_skipped_syms

    print("\n" + "=" * 50)
    print("Updating Plugify...")
    plugify_updated, plugify_skipped, plugify_updated_syms, plugify_skipped_syms = update_plugify(
        yaml_data, func_lib_map, platforms, script_dir, alias_to_name_map, debug
    )
    print(f"  Updated: {plugify_updated}, Skipped: {plugify_skipped}")
    all_updated_symbols["Plugify"] = plugify_updated_syms
    all_skipped_symbols["Plugify"] = plugify_skipped_syms

    # Summary
    total_updated = css_updated + cs2f_updated + cs2kz_updated + swifts2_updated + plugify_updated
    total_skipped = css_skipped + cs2f_skipped + cs2kz_skipped + swifts2_skipped + plugify_skipped

    print("\n" + "=" * 50)
    print(f"Total: {total_updated} updates, {total_skipped} skipped")

    # Print debug info if enabled
    if debug:
        print_debug_info("Summary", missing_symbols, all_updated_symbols, all_skipped_symbols)


if __name__ == "__main__":
    main()
